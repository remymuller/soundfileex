import soundfile as sf
from ctypes.util import find_library as _find_library

# get PySoundfile FFI
ffi = sf._ffi
# ffi = FFI()

# add missing definitions
ffi.cdef("""
enum
{
    // SFC_GET_CUE_COUNT               = 0x10CD,
    // SFC_GET_CUE                     = 0x10CE,
    // SFC_SET_CUE                     = 0x10CF,

    SFC_GET_INSTRUMENT              = 0x10D0,
    SFC_SET_INSTRUMENT              = 0x10D1,

    SFC_GET_LOOP_INFO               = 0x10E0,
};

typedef struct
{   int32_t     indx ;
    uint32_t    position ;
    int32_t     fcc_chunk ;
    int32_t     chunk_start ;
    int32_t     block_start ;
    uint32_t    sample_offset ;
    char name [256] ;
} SF_CUE_POINT ;

typedef struct 
{   uint32_t cue_count ; 
    SF_CUE_POINT cue_points [100] ; 
} SF_CUES;

enum
{   /*
    **  The loop mode field in SF_INSTRUMENT will be one of the following.
    */
    SF_LOOP_NONE = 800,
    SF_LOOP_FORWARD,
    SF_LOOP_BACKWARD,
    SF_LOOP_ALTERNATING
};

typedef struct
{   int gain ;
    char basenote, detune ;
    char velocity_lo, velocity_hi ;
    char key_lo, key_hi ;
    int loop_count ;

    struct
    {   int mode ;
        uint32_t start ;
        uint32_t end ;
        uint32_t count ;
    } loops [16] ; /* make variable in a sensible way */
} SF_INSTRUMENT ;

typedef struct
{
    short   time_sig_num ;  /* any positive integer    > 0  */
    short   time_sig_den ;  /* any positive power of 2 > 0  */
    int     loop_mode ;     /* see SF_LOOP enum             */

    int     num_beats ;     /* this is NOT the amount of quarter notes !!!*/
                            /* a full bar of 4/4 is 4 beats */
                            /* a full bar of 7/8 is 7 beats */

    float   bpm ;           /* suggestion, as it can be calculated using other fields:*/
                            /* file's length, file's sampleRate and our time_sig_den*/
                            /* -> bpms are always the amount of _quarter notes_ per minute */

    int root_key ;          /* MIDI note, or -1 for None */
    int future [6] ;
} SF_LOOP_INFO ;

struct SF_CHUNK_INFO
{   char        id [64] ;   /* The chunk identifier. */
    unsigned    id_size ;   /* The size of the chunk identifier. */
    unsigned    datalen ;   /* The size of that data. */
    void        *data ;     /* Pointer to the data. */
} ;

typedef struct SF_CHUNK_INFO SF_CHUNK_INFO ;

int sf_set_chunk (SNDFILE * sndfile, const SF_CHUNK_INFO * chunk_info) ;
typedef struct SF_CHUNK_ITERATOR SF_CHUNK_ITERATOR ;

SF_CHUNK_ITERATOR *
sf_get_chunk_iterator (SNDFILE * sndfile, const SF_CHUNK_INFO * chunk_info) ;

SF_CHUNK_ITERATOR *
sf_next_chunk_iterator (SF_CHUNK_ITERATOR * iterator) ;

int
sf_get_chunk_size (const SF_CHUNK_ITERATOR * it, SF_CHUNK_INFO * chunk_info) ;

int
sf_get_chunk_data (const SF_CHUNK_ITERATOR * it, SF_CHUNK_INFO * chunk_info) ;

""")

# # reopen libsndfile with new definitions
#libsndfile = ffi.dlopen(_find_library('sndfile'))
#sf._snd = libsndfile
libsndfile = sf._snd


class Cue(object):
    """
    """

    def __init__(self, id, name, sample_offset, fcc_chunk='data', chunk_start=0, block_start=0, position=0):
        """
        int32_t     indx ; // 
        uint32_t    position ;
        int32_t     fcc_chunk ;
        int32_t     chunk_start ;
        int32_t     block_start ;
        uint32_t    sample_offset ;
        char name [256] ;

        From https://sites.google.com/site/musicgapi/technical-documents/wav-file-format#inst
        0x00    4   ID  unique identification value
        0x04    4   Position    play order position
        0x08    4   Data Chunk ID   RIFF ID of corresponding data chunk
        0x0c    4   Chunk Start Byte Offset of Data Chunk *
        0x10    4   Block Start Byte Offset to sample of First Channel
        0x14    4   Sample Offset   Byte Offset to sample byte of First Channel

        ID
        Each cue point has a unique identification value used to associate cue points with information in other chunks. 
        For example, a Label chunk contains text that describes a point in the wave file by referencing the associated cue point.

        Position
        The position specifies the sample offset associated with the cue point in terms of the sample's position in the final 
        stream of samples generated by the play list. Said in another way, if a play list chunk is specified, 
        the position value is equal to the sample number at which this cue point will occur during playback of the entire play list as defined by the play list's order. If no play list chunk is specified this value should be 0.

        Data Chunk ID
        This value specifies the four byte ID used by the chunk containing the sample that corresponds to this cue point. 
        A Wave file with no play list is always "data". A Wave file with a play list containing both sample data and silence may 
        be either "data" or "slnt".

        Chunk Start
        The Chunk Start value specifies the byte offset into the Wave List Chunk of the chunk containing the sample 
        that corresponds to this cue point. This is the same chunk described by the Data Chunk ID value. 
        If no Wave List Chunk exists in the Wave file, this value is 0. If a Wave List Chunk exists, 
        this is the offset into the "wavl" chunk. The first chunk in the Wave List Chunk would be specified with a value of 0.

        Block Start
        The Block Start value specifies the byte offset into the "data" or "slnt" Chunk to the start of the block containing 
        the sample. The start of a block is defined as the first byte in uncompressed PCM wave data or the last byte in compressed 
        wave data where decompression can begin to find the value of the corresponding sample value.

        Sample Offset
        The Sample Offset specifies an offset into the block (specified by Block Start) for the sample that corresponds 
        to the cue point. In uncompressed PCM waveform data, this is simply the byte offset into the "data" chunk. 
        In compressed waveform data, this value is equal to the number of samples (may or may not be bytes) 
        from the Block Start to the sample that corresponds to the cue point.
        """
        self.id             = id
        self.position       = position
        self.name           = name
        self.sample_offset  = sample_offset
        self.fcc_chunk      = fcc_chunk
        self.chunk_start    = chunk_start
        self.block_start    = block_start


class InstrumentChunk(object):
    """
    """

    def __init__(self, gain=0, basenote=60, detune=0, 
                lovel=0, hivel=0, lokey=0, hikey=127, loops=[]):
        self.basenote = basenote
        self.detune   = detune
        self.gain     = gain
        self.lovel    = lovel
        self.hivel    = hivel
        self.lokey    = lokey
        self.hikey    = hikey
        self.loops    = loops  

    def __repr__(self):
        return "(basenote=%d, detune=%d, gain=%d, lovel=%d, hivel=%d, lokey=%d, hikey=%d, loops=%s)" % (
            self.basenote, 
            self.detune, 
            self.gain,
            self.lovel,
            self.hivel,
            self.lokey,
            self.hikey,
            str(self.loops)
            )


def to_int(e):
    return int(ffi.cast("int", e))


class SoundFileEx(sf.SoundFile):

    # def __init__(self, *args, **kwargs):
    #     sf.SoundFile.__init__(self, args, kwargs)

    def get_instrument_chunk(self):
        """
        """
        chunk = ffi.new("SF_INSTRUMENT*")
        size  = ffi.sizeof("SF_INSTRUMENT")
        result = libsndfile.sf_command(self._file, libsndfile.SFC_GET_INSTRUMENT, chunk, size)
        if result == libsndfile.SF_FALSE:
            error = ffi.string(libsndfile.sf_strerror(self._file))
            print(error)
            raise RuntimeError(error)

        basenote = to_int(chunk.basenote)
        detune   = to_int(chunk.detune)
        gain     = to_int(chunk.gain)
        lovel    = to_int(chunk.velocity_lo)
        hivel    = to_int(chunk.velocity_hi)
        lokey    = to_int(chunk.key_lo)
        hikey    = to_int(chunk.key_hi)
        loop_count = to_int(chunk.loop_count)

        loops = []
        for i in range(loop_count):
            start = int(chunk.loops[i].start)
            end   = int(chunk.loops[i].end)
            mode  = int(chunk.loops[i].mode)
            count = int(chunk.loops[i].count)
            loops.append((start, end, mode, count))

        return InstrumentChunk(gain=gain, basenote=basenote, detune=detune, 
                lovel=lovel, hivel=hivel, lokey=lokey, hikey=hikey, loops=loops)


    def set_instrument_chunk(self, gain=0, basenote=60, detune=0, 
                            lovel=1, hivel=1, lokey=0, hikey=127, loops=[]):
        """

        snd.set_instrument_chunk(basenote=note, 
                                 detune=detune, 
                                 loops=[(start, end)])
        """
        # TODO: test ranges
        assert len(loops) < 16

        chunk                = ffi.new("SF_INSTRUMENT*")
        chunk.basenote       = ffi.cast("char", basenote)
        chunk.detune         = ffi.cast("char", detune)
        chunk.gain           = ffi.cast("int", gain)
        chunk.velocity_lo    = ffi.cast("char", lovel)
        chunk.velocity_hi    = ffi.cast("char", hivel)
        chunk.key_lo         = ffi.cast("char", lokey)
        chunk.key_hi         = ffi.cast("char", hikey)
        chunk.loop_count     = ffi.cast("int", len(loops))

        for i in range(len(loops)):
            loop    = loops[i]
            assert len(loop) >= 2
            start   = loop[0]
            end     = loop[1]
            mode    = loop[2] if len(loop) > 2 else libsndfile.SF_LOOP_FORWARD
            count   = loop[3] if len(loop) > 3 else 0

            chunk.loops[i].start = ffi.cast("uint32_t", start)
            chunk.loops[i].end   = ffi.cast("uint32_t", end)
            chunk.loops[i].mode  = mode
            chunk.loops[i].count = ffi.cast("uint32_t", count)

        size    = ffi.sizeof("SF_INSTRUMENT")
        result  = libsndfile.sf_command(self._file, libsndfile.SFC_SET_INSTRUMENT, chunk, size)
        if result == libsndfile.SF_FALSE:
            error = ffi.string(libsndfile.sf_strerror(self._file))
            print(error)
            raise RuntimeError(error)


    # SFC_GET_CUE_COUNT               = 0x10CD,
    # SFC_GET_CUE                     = 0x10CE,
    # SFC_SET_CUE                     = 0x10CF,

    def set_cues(self, cues):
        chunk = ffi.new("SF_CUES*")
        chunk.cue_count = len(cues)
        for i in range(len(cues)):
            #chunk.cue_points[i] = cues[]
            pass

    def get_cues(self):
        pass

    def get_num_cues(self):
        pass

    # TODO: property cues using iterator (for cue in snd.cues: print cue)

    def get_loop_info(self):
        """
        short   time_sig_num ;  /* any positive integer    > 0  */
        short   time_sig_den ;  /* any positive power of 2 > 0  */
        int     loop_mode ;     /* see SF_LOOP enum             */

        int     num_beats ;     /* this is NOT the amount of quarter notes !!!*/
                                /* a full bar of 4/4 is 4 beats */
                                /* a full bar of 7/8 is 7 beats */

        float   bpm ;           /* suggestion, as it can be calculated using other fields:*/
                                /* file's length, file's sampleRate and our time_sig_den*/
                                /* -> bpms are always the amount of _quarter notes_ per minute */

        int root_key ;          /* MIDI note, or -1 for None */
        int future [6] ;
        """
        chunk = ffi.new("SF_LOOP_INFO*")
        size  = ffi.sizeof("SF_LOOP_INFO")
        result = libsndfile.sf_command(self._file, libsndfile.SFC_GET_LOOP_INFO, chunk, size)
        if result == libsndfile.SF_FALSE:
            error = ffi.string(libsndfile.sf_strerror(self._file))
            print(error)
            #raise RuntimeError(error)

        num         = int(chunk.time_sig_num)
        den         = int(chunk.time_sig_den)
        loop_mode   = int(chunk.loop_mode)
        num_beats   = int(chunk.num_beats)
        bpm         = float(chunk.bpm)
        root_key    = int(chunk.root_key)
        print(num, den, num_beats, bpm, root_key, loop_mode)

        # basenote = ffi.cast("int", chunk.basenote)


def test_loop_info():
    """
    """

    with SoundFileEx("test.wav", "r") as snd:
        filename = "/Users/muller/Music/Loops/080-C-TripHop.aif"
        filename = "/Users/muller/Music/Loops/120-Guitar-B Ddim-2.WAV"
        loop_info = snd.get_loop_info()


if __name__ == "__main__":
    import numpy
    import math 

    sr          = 44100
    f0          = 441
    midipitch   = 69 + 12 * (math.log(f0 / 440.0) / math.log(2))
    note        = int(math.floor(midipitch) + 0.5)    # nearest integer note
    detune      = int(math.floor(100 * (midipitch - note) + 0.5))  # detune in cents
    period      = int(math.floor(sr / float(f0) + 0.5))
    loop_start  = 101*period
    loop_end    = 102*period
    loop_count  = 0
    print("pitch: %f, note: %d, detune: %d cents" % (midipitch, note, detune))

    L = sr
    n = numpy.arange(L)
    t = n / float(sr)
    x = numpy.sin(2*numpy.pi*f0*t)

    with SoundFileEx("test.wav", "w", samplerate=sr, channels=1, format="WAV", subtype="FLOAT") as snd:
        snd.set_instrument_chunk(basenote=note, detune=detune, loops=[(loop_start, loop_end)])
        snd.write(x)

    with SoundFileEx("test.wav", "r") as snd:
        chunk = snd.get_instrument_chunk()
        print(chunk)

    with SoundFileEx("test.aiff", "w", samplerate=sr, channels=1, format="AIFF", subtype="PCM_16") as snd:
        snd.set_instrument_chunk(basenote=note, detune=detune, loops=[(loop_start, loop_end)])
        snd.write(x)

    with SoundFileEx("test.aiff", "r") as snd:
        chunk = snd.get_instrument_chunk()
        print(chunk)

    test_loop_info()

    # TODO: cleanup
